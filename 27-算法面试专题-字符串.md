```java
package com.xiaodai.algorithm;

/**
 * Author ：dai
 * Date   ：2021/3/17 2:01 下午
 * Description：
 */
public class StringUtil {

    /**
     * 1、 判断两个字符串是否互为变形词
     *
     * @param str1
     * @param str2
     * @return
     */
    public boolean isDeformation(String str1, String str2) {

        if (str1 == null || str2 == null || str1.length() != str2.length()) {
            return false;
        }

        char[] chars1 = str1.toCharArray();
        char[] chars2 = str2.toCharArray();

        // 字符词频统计表
        int[] map = new int[256];

        // 对第一个字符串中的字符进行词频统计
        for (char c : chars1) {
            map[c]++;
        }

        // 用第二个字符串的字符去消除词频
        for (char c : chars2) {
            if (map[c]-- == 0) {
                return false;
            }
        }

        return true;
    }


    /**
     * 2、 移除字符串中连续出现k个0的子串
     *
     * @param str
     * @param k
     * @return
     */
    public String removeKZeros(String str, int k) {
        if (str == null || k < 1) {
            return str;
        }

        char[] chars = str.toCharArray();
        int count = 0, start = -1;
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] == '0') {
                count++;
                start = start == -1 ? i : start;
            } else {
                // 如果不等于'0'需要从start位置开始，去掉count个'0'字符
                if (count == k) {
                    while (count-- != 0) {
                        // ascii码空白字符的表示为十进制的0。chars[1] = 0 表示把1位置的字符，替换为空白符
                        chars[start++] = 0;
                    }
                }
                // 一轮剔除结束，count和start归位
                count = 0;
                start = -1;
            }
        }

        // 最后一轮，即如果字符串是以'0'字符结尾的。最后要单独结算一次
        if (count == k) {
            while (count-- != 0) {
                chars[start++] = 0;
            }
        }

        return String.valueOf(chars);
    }


    /**
     * 3、返回一个字符串的字符统计串
     * @param str
     * @return
     */
    public String getCountString(String str) {
        if(str == null || str.equals("")) {
            return "";
        }

        char[] chars = str.toCharArray();
        String res = String.valueOf(chars[0]);
        int num = 1;
        for (int i = 1; i < chars.length; i++) {
            // 结算
            if(chars[i] != chars[i-1]) {
                res = concat(res, String.valueOf(num), String.valueOf(chars[i]));
                num = 1;
            } else {
                num++;
            }
        }
        return concat(res, String.valueOf(num), "");
    }

    private String concat(String s1, String s2, String s3) {
        return s1 + "_" + s2 + (s3.equals("") ? s3 : "_" + s3);
    }

    /**
     * 4、判断字符数组中，是否所有的字符均出现一次
     * @param chars
     * @return
     */
    public boolean isUnique(char[] chars) {
        if(chars == null) {
            return true;
        }

        boolean[] map = new boolean[256];
        for (int i = 0; i < chars.length; i++) {
            if(map[chars[i]]) {
                return false;
            }
            map[chars[i]] = true;
        }
        return true;
    }


    /**
     * 5、括号字符匹配问题：输入一个字符串，包含'(','[','{',')',']','}'几种括号，求是否是括号匹配的结果。
     * @param s
     * @return
     */
    public static boolean isValid(String s) {

        if (s == null || s.length() == 0) {
            return true;
        }

        char[] str = s.toCharArray();
        Stack<Character> stack = new Stack<>();

        for (int i = 0; i < str.length; i++) {
            char cha = str[i];
            // 遇到左括号，添加相应的右括号
            if (cha == '(' || cha == '[' || cha == '{') {
                stack.add(cha == '(' ? ')' : (cha == '[' ? ']' : '}'));
            } else { // 遇到右括号，弹出栈，比对相等
                if (stack.isEmpty()) {
                    return false;
                }
                char last = stack.pop();
                if (cha != last) {
                    return false;
                }
            }
        }

        // 遍历结束，栈刚好为空。满足匹配要求
        return stack.isEmpty();
    }


    /**
     * 6、求一个字符串无重复最长子串
     
     * 子串和子序列的区别，子串必须要连续，子序列不一定要连续。
     * 遇到子串和子序列的问题，可以按照一种经典思路：
     * 按照i位置结尾的情况下答案是什么？求所有可能的结尾即可，所有位置结尾的答案都求出，最大的就是我们的目标答案
     * 时间复杂度O(N)，空间复杂度O(1)，由于申请的空间是固定长度256
     * @param s
     * @return
     */
    public static int lengthOfLongestSubstring(String s) {
        // base case 过滤无效参数
        if (s == null || s.equals("")) {
            return 0;
        }

        char[] str = s.toCharArray();
        int[] map = new int[256];
        // 辅助数组。保存字符出现的位置，字符的范围为可显示字符0~127，扩展ascii字符128~255
        for (int i = 0; i < 256; i++) {
            // 默认所有的字符都没出现过
            map[i] = -1;
        }
        // i位置往左推，推不动的位置第一个因素是再次遇到了i位置上的元素，第二个因素是i-1位置当初推了多远。
        // 这两个因素的限制，哪个限制位置离当前i位置近，就是当前字符i最远推到的位置，map[i]
        // 收集答案。len是收集全局的最大长度
        int len = 0;
        int pre = -1; // i-1位置结尾的情况下，往左推，推不动的位置是谁。用来每次保存i之前一个位置的答案
        int cur = 0;
        for (int i = 0; i != str.length; i++) {
            // i位置结尾的情况下，往左推，推不动的位置是谁
            // pre (i-1信息) 更新成 pre(i 结尾信息)
            // 上次推不动的，和当前字符上次出现的位置map[str[i]]的位置，取大的
            pre = Math.max(pre, map[str[i]]);
            // 找到了当前推不动的位置，当前不重复子串的长度就是i-pre
            cur = i - pre;
            // 全局最大的子串长度，是否被更新，决定是否要收集
            len = Math.max(len, cur);
            // 更新当前字符出现的位置是当前位置
            map[str[i]] = i;
        }
        return len;
    }


    /**
     * 7、最长回文子串问题。
     * 该解法是扩散法。时间复杂度为O(N * N)。(最优解是马拉车算法，可以优化该题到O(N)，不掌握)
     * @param s
     * @return
     */
    public static String longestPalindrome2(String s) {

        if(s.length() == 0) {
            return s;
        }

        // 全局最大回文长度
        int res = 1;
        // 全局最大回文长度对应的左位置
        int ll = 0;
        // 全局最大回文长度对应的右位置
        int rr = 0;


        for (int i = 0; i < s.length(); i++) {

            // 以i为下标的奇数情况，是否有更大的len来更新res
            int l = i - 1;
            int r = i + 1;

            // l和r都在合法范围。且l和r位置字符相等，可以继续扩散
            while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
                int len = (r - l + 1);
                // 更新最长回文串的长度
                if(len > res) {
                    res = len;
                    ll = l;
                    rr = r;
                }
                // 扩散
                l--;
                r++;
            }

            // 以i为下标偶数的情况。是否有更大的len来更新全局res
            l = i;
            r = i + 1;
            // l和r都在合法范围。且l和r位置字符相等，可以继续扩散
            while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
                int len = (r - l + 1);
                // 更新最长回文串的长度
                if(len > res) {
                    res = len;
                    ll = l;
                    rr = r;
                }
                // 扩散
                l--;
                r++;
            }

        }

        return s.substring(ll, rr + 1);
    }


    /**
     * 8、字符串最长公共前缀问题
     *
     **/
    public static String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        // 拿出第一个字符串。当成初始值
        char[] chs = strs[0].toCharArray();
        // 所有字符串都匹配的最大长度，等同于每个字符串和初始字符串匹配的全局最小长度
        int min = Integer.MAX_VALUE;

        for (String str : strs) {

            char[] tmp = str.toCharArray();
            int index = 0;
            while (index < tmp.length && index < chs.length) {
                if (chs[index] != tmp[index]) {
                    break;
                }
                index++;
            }
            // 更新min
            min = Math.min(index, min);
            // 如果有任意一个字符串和初始串不匹配，直接返回""
            if (min == 0) {
                return "";
            }
        }
        // 截取min的长度，就是所有字符串共同匹配的最大长度
        return strs[0].substring(0, min);
    }


}
```